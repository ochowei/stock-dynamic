# -*- coding: utf-8 -*-
"""Dynamic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zBF_qZ9T9X1_728HBztNtFMp6yuOrcGc
"""

#儲存格1

# @title
#儲存格2
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import re
import argparse

# @title
#儲存格3
import pytz # 引入 pytz 函式庫

def analyze_fixed_time_lag(stock_data: pd.DataFrame, ticker: str, interval: str, holding_hours: float):
    """
    分析一檔股票在給定數據下，與 {holding_hours} 小時前的 K 線收盤價的價差。
    Analyzes the price difference of a stock based on provided data,
    between the current bar and the close price {holding_hours} hours prior.
    """
    if stock_data.empty:
        print(f"錯誤：{ticker} 沒有提供數據。")
        print(f"ERROR: No data provided for {ticker}.")
        return None, None

    # 數據已預先處理，直接使用
    print(f"Processing {ticker} data. Total bars: {len(stock_data)}.")
    print("-" * 30)


    # --- 參數計算 (Parameter Calculation) ---
    try:
        minutes_per_bar = int(re.findall(r'(\d+)', interval)[0])
    except Exception:
        print(f"錯誤：無法從 K 線間隔 '{interval}' 提取分鐘數。請使用 '1m', '5m', '15m' 格式。")
        print(f"ERROR: Could not parse minutes from interval '{interval}'. Please use '1m', '5m', '15m' format.")
        return None, None

    total_minutes_to_lag = holding_hours * 60

    if total_minutes_to_lag % minutes_per_bar != 0:
        print(f"錯誤：持有時間 {holding_hours} 小時 ({total_minutes_to_lag} 分鐘) 不是 K 線間隔 {minutes_per_bar} 分鐘的整數倍。")
        print(f"ERROR: Holding period {holding_hours} hours ({total_minutes_to_lag} mins) is not an integer multiple of the K-bar interval ({minutes_per_bar} mins).")
        return None, None

    lag_periods = int(total_minutes_to_lag / minutes_per_bar)

    # print(f"分析參數 (Analysis Parameters)：")
    # print(f"  - K線間隔 (Interval): {interval} ({minutes_per_bar} 分鐘)")
    # print(f"  - 持有時長 (Holding Period): {holding_hours} 小時 (Hours)")
    # print(f"  - 回溯 K 棒 (Lag Periods): {lag_periods} 根 K 棒 (bars)")
    # print("-" * 30)

    # --- 核心計算 (Core Calculation) ---
    stock_data['P_buy'] = stock_data['Close'].shift(lag_periods)
    stock_data['P_sell'] = stock_data['Close']

    analysis_df = stock_data.dropna().copy()

    if analysis_df.empty:
        print(f"錯誤：數據量不足，無法進行 {holding_hours} 小時的回測分析。")
        print(f"ERROR: Not enough data for a {holding_hours}-hour lookback analysis.")
        return None, None

    analysis_df['price_diff'] = analysis_df['P_sell'] - analysis_df['P_buy']
    analysis_df['return'] = (analysis_df['P_sell'] - analysis_df['P_buy']) / analysis_df['P_buy']

    # --- 統計分析結果 (Statistical Analysis) ---
    total_trades = len(analysis_df)
    losing_trades = (analysis_df['price_diff'] < 0).sum()

    results = {
        "ticker": ticker,
        "holding_hours": holding_hours,
        "total_trades": total_trades,
        "loss_probability": losing_trades / total_trades if total_trades > 0 else 0,
        "avg_price_diff": analysis_df['price_diff'].mean(),
        "avg_gain_diff": analysis_df[analysis_df['price_diff'] > 0]['price_diff'].mean(),
        "avg_loss_diff": analysis_df[analysis_df['price_diff'] < 0]['price_diff'].mean(),
        "expected_return": analysis_df['return'].mean(),
        "win_rate": (analysis_df['return'] > 0).sum() / total_trades if total_trades > 0 else 0,
    }

    return results, analysis_df

# @title
#儲存格4
def print_results(results: dict):
    """格式化並印出中英分析結果"""
    if not results: return

    holding_hours = results['holding_hours']

    # print(f"======= {results['ticker']} 股票 {holding_hours} 小時持有期分析結果 ({holding_hours}-Hour Holding Period Analysis) =======")
    # print(f"總有效交易次數 (Total Trades): {results['total_trades']:,}")
    # print("-" * 40)

    # print(f"下跌機率 (Probability of Loss): {results['loss_probability']:.2%}")
    # print(f"    (定義: {holding_hours} 小時後價格低於 {holding_hours} 小時前價格的機率)")
    # print(f"    (Definition: Probability that P_sell < P_buy)")

    # print("-" * 40)
    # print(f"價差期望值 (Expected Price Difference): ${results['avg_price_diff']:.4f}")
    # print(f"    - 平均獲利價差 (Avg. Gain Amount): ${results.get('avg_gain_diff', 0):.4f}")
    # print(f"    - 平均虧損價差 (Avg. Loss Amount): ${results.get('avg_loss_diff', 0):.4f}")

    print("-" * 40)
    print(f"價值期望值 (Expected Return %): {results['expected_return']:.4%}")
    # print(f"    (報酬率 > 0 的機率 (Win Rate %): {results['win_rate']:.2%})")

    print("=" * 70)
    # print("註 (Note): 此分析未考慮交易手續費或滑價成本 (This analysis excludes commissions and slippage.)")

# --- 這裡開始是修改過的函式 (This function is modified) ---

def plot_results(results: dict, analysis_df: pd.DataFrame, output_folder: str = 'output_img'):
    """
    將分析結果視覺化 (全英文圖表)
    修改：繪製每筆交易的 "報酬率 (%)" 隨時間變化的圖表
    """
    if not results or analysis_df.empty: return

    holding_hours = results['holding_hours']

    sns.set_style("whitegrid")
    plt.figure(figsize=(15, 7))

    # 建立「交易序號」的 X 軸 (Create a numerical index for the x-axis)
    x_values = range(len(analysis_df))

    # --- 核心修改 (Core Modification) ---
    # 1. 繪製 'return' 欄位，並 * 100 轉換為百分比
    #    (Plot the 'return' column and multiply by 100 to convert to percentage)
    plt.plot(x_values, analysis_df['return'].values * 100,
             label='Return (Percentage)', color='dodgerblue', linewidth=0.8)

    # 2. 損益兩平線仍然是 0 (Breakeven line is still 0)
    plt.axhline(y=0, color='red', linestyle='--', label='Breakeven (Return = 0%)')

    # 3. 繪製 "平均報酬率" (Plot the "Average Return")
    avg_return = results['expected_return']
    plt.axhline(y=avg_return * 100, color='orange', linestyle=':',
                label=f'Average Return ({avg_return:.4%})')
    # --- 修改結束 (End of Modification) ---


    # 建立自訂的 X 軸標籤 (Create custom x-axis ticks)
    num_ticks = 10
    tick_indices = np.linspace(0, len(analysis_df) - 1, num_ticks, dtype=int)
    tick_labels = analysis_df.index[tick_indices].strftime('%m-%d %H:%M')

    plt.xticks(ticks=tick_indices, labels=tick_labels, rotation=30, ha='right')

    # 更新標題和 Y 軸標籤 (Update Title and Y-axis Label)
    plt.title(f"{results['ticker']} - {holding_hours}-Hour Holding Return (Per Trade)", fontsize=16)
    plt.xlabel("Date (Skipping Non-Trading Periods)", fontsize=12)
    plt.ylabel("Return (%)", fontsize=12) # Y 軸標籤改為 Return (%)
    plt.legend()

    plt.tight_layout()

    plot_filename = f"{output_folder}/{results['ticker']}_{holding_hours}hr.png"
    plt.savefig(plot_filename)
    print(f"Plot saved as {plot_filename}")
    # plt.show()

# @title
#儲存格5
# --- 您可以在這裡修改共用參數 (You can modify parameters here) ---
# 持有小時 (Holding Hours) - 兩項分析共用
HOLDING_HOURS = 2.5
# 股票代碼 (Ticker Symbol) - 兩項分析共用
TICKER_SYMBOLS = ['00635U.TW','TSLA','ADBE','ALAB','AMD','BE','BND','CIFR','EOSE','FIG','GLD','GOOG','GRAB','IBIT','IONQ','LEU','MGK','MP','NVDA','NVTS','ONDS','POWI','RBRK','RCAT','SIVR','SMR','SOFI','TMDX','TSM','UUUU','VOO','VST','WWR']

# @title

#儲存格6
# --- 參數定義 (Parameter Definitions) ---
# (保留儲存格 5, 6, 7/8 中的所有參數定義)

# 分析 1 參數
INTERVAL_SHORT = '30m'

# 分析 2 & 3 參數
INTERVAL_LONG = '60m'
# (註：原儲存格 7 和 7/8 都使用 '60m' 和 '5d'，我們在批次下載時使用)


# --- 執行主程式 (Run Main Program) ---
if __name__ == "__main__":
    plt.ioff()
    # --- 1. 設定命令列參數解析 ---
    parser = argparse.ArgumentParser(
        description="執行 stock-dynamic 分析，可自訂分析週期。"
    )
    parser.add_argument(
        "-p", "--period",
        type=str,
        default="5d", # 預設值
        help="指定 yfinance 下載資料的週期 (例如: '5d', '7d', '1mo')"
    )
    parser.add_argument(
        "--plot-on-profit",
        action="store_true",
        help="僅在價值期望值 (Expected Return) > 0 時才儲存圖表。"
    )
    # (未來也可以在這裡新增 --tickers 或 --hours 參數)
    args = parser.parse_args()


    print("=======================================================")
    print(f"======= 開始批次下載資料 (Starting Batch Download) =======")
    print(f"Tickers: {TICKER_SYMBOLS}")
    print(f"Intervals: {INTERVAL_SHORT}, {INTERVAL_LONG}")
    print(f"Period: {args.period}") # <-- 使用 args.period
    print("=======================================================\n")

    # --- 2. 批次下載所有資料 ---
    data_short_interval_batch = yf.download(
        tickers=TICKER_SYMBOLS,
        interval=INTERVAL_SHORT,
        period=args.period, # <-- 使用 args.period
        progress=True,
        prepost=False,
        group_by='ticker'
    )

    data_long_interval_batch = yf.download(
        tickers=TICKER_SYMBOLS,
        interval=INTERVAL_LONG,
        period=args.period, # <-- 使用 args.period
        progress=True,
        prepost=False,
        group_by='ticker'
    )

    # --- 2. 統一處理時區 (在迴圈外處理) ---
    new_york_tz = pytz.timezone('America/New_York')

    if not data_short_interval_batch.empty:
        if data_short_interval_batch.index.tzinfo is None:
            data_short_interval_batch.index = data_short_interval_batch.index.tz_localize('UTC').tz_convert(new_york_tz)
        else:
            data_short_interval_batch.index = data_short_interval_batch.index.tz_convert(new_york_tz)
        print(f"1m 資料已轉換至 'America/New_York' 時區。")

    if not data_long_interval_batch.empty:
        if data_long_interval_batch.index.tzinfo is None:
            data_long_interval_batch.index = data_long_interval_batch.index.tz_localize('UTC').tz_convert(new_york_tz)
        else:
            data_long_interval_batch.index = data_long_interval_batch.index.tz_convert(new_york_tz)
        print(f"60m 資料已轉換至 'America/New_York' 時區。")

    print("\n======= 資料下載與處理完畢。開始執行分析... =======")


    # --- 3. 執行單一迴圈分析 ---
    for TICKER_SYMBOL in TICKER_SYMBOLS:

        print(f"\n=======================================================")
        print(f"======= 正在分析 (Now Analyzing): {TICKER_SYMBOL} =======")
        print(f"=======================================================\n")

        # --- 提取資料 (Extract Data) ---
        try:
            stock_data_short_interval = data_short_interval_batch[TICKER_SYMBOL].dropna()
            stock_data_long_interval = data_long_interval_batch[TICKER_SYMBOL].dropna()
        except KeyError:
            print(f"*** 錯誤：無法從批次下載中提取 {TICKER_SYMBOL} 的資料。跳過... ***")
            continue
        except Exception as e:
            print(f"*** 提取 {TICKER_SYMBOL} 資料時發生未知錯誤: {e}。跳過... ***")
            continue

        if stock_data_short_interval.empty and stock_data_long_interval.empty:
            print(f"*** {TICKER_SYMBOL} 沒有可分析的資料。跳過... ***")
            continue

        # --- 執行分析 (SHORT) ---
        if not stock_data_short_interval.empty:
            print(f"--- 分析 (SHORT) ({INTERVAL_SHORT} K線, {HOLDING_HOURS * 1} 小時) ---")
            analysis_results_short, detailed_df_short = analyze_fixed_time_lag(
                stock_data=stock_data_short_interval, # <-- 傳入資料
                ticker=TICKER_SYMBOL,
                interval=INTERVAL_SHORT,
                holding_hours=HOLDING_HOURS * 1
            )
            if analysis_results_short and not detailed_df_short.empty:
                if not args.plot_on_profit or (args.plot_on_profit and analysis_results_short['expected_return'] > 0):
                    print_results(analysis_results_short)
                    plot_results(analysis_results_short, detailed_df_short)
        else:
             print(f"--- {TICKER_SYMBOL} 缺少 {INTERVAL_SHORT} 資料，跳過分析 (SHORT) ---")


        # --- 執行分析 (LONG BASE) ---
        if not stock_data_long_interval.empty:
            print(f"\n--- 分析 (LONG BASE) ({INTERVAL_LONG} K線, {HOLDING_HOURS * 2} 小時) ---")
            analysis_results_long_base, detailed_df_long_base = analyze_fixed_time_lag(
                stock_data=stock_data_long_interval, # <-- 傳入資料
                ticker=TICKER_SYMBOL,
                interval=INTERVAL_LONG,
                holding_hours=HOLDING_HOURS * 2
            )
            if analysis_results_long_base and not detailed_df_long_base.empty:
                if not args.plot_on_profit or (args.plot_on_profit and analysis_results_long_base['expected_return'] > 0):
                    print_results(analysis_results_long_base)
                    plot_results(analysis_results_long_base, detailed_df_long_base)

            # --- 執行分析 (LONG EXT) ---
            print(f"\n--- 分析 (LONG EXT) ({INTERVAL_LONG} K線, {HOLDING_HOURS * 4} 小時) ---")
            analysis_results_long_extended, detailed_df_long_extended = analyze_fixed_time_lag(
                stock_data=stock_data_long_interval, # <-- 傳入資料
                ticker=TICKER_SYMBOL,
                interval=INTERVAL_LONG,
                holding_hours=HOLDING_HOURS * 4
            )
            if analysis_results_long_extended and not detailed_df_long_extended.empty:
                if not args.plot_on_profit or (args.plot_on_profit and analysis_results_long_extended['expected_return'] > 0):
                    print_results(analysis_results_long_extended)
                    plot_results(analysis_results_long_extended, detailed_df_long_extended)
        else:
            print(f"--- {TICKER_SYMBOL} 缺少 {INTERVAL_LONG} 資料，跳過分析 (LONG) ---")


    print(f"\n======= 所有分析結束 (All Analyses Complete) =======")
